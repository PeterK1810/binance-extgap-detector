#!/usr/bin/env python3
"""
Binance External Gap Signal Monitor - Multi-Symbol 15m
========================================================

Monitors 4 Binance Futures symbols for external gap signals on 15m timeframe.
Tracks WIN/LOSE/NULL outcomes for every candle after gap detection.

Features:
- Multi-symbol monitoring (BTC, ETH, SOL, XRP) in single process
- Continuous signal tracking until reversal
- Per-symbol and aggregated statistics
- All-time max streak persistence
- Telegram notifications for every 15m candle
- Replit deployment ready (uses Secrets for credentials)

Signal Logic:
- BULLISH gap active: green candle = WIN, red candle = LOSE
- BEARISH gap active: red candle = WIN, green candle = LOSE
- Doji (close = open) = NULL (doesn't break streaks)

Author: Generated by Claude Code
Date: 2025-12-08
"""

from __future__ import annotations

import asyncio
import json
import logging
import os
import signal
import sys
import uuid
from collections import deque
from dataclasses import dataclass, field
from datetime import datetime, timedelta, timezone
from pathlib import Path
from typing import Deque, Dict, List, Optional

import aiohttp
import websockets
from dotenv import load_dotenv

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Symbols to monitor (Binance Futures)
SYMBOLS = ["BTCUSDT", "ETHUSDT", "SOLUSDT", "XRPUSDT"]

# Timeframe
TIMEFRAME = "15m"
TIMEFRAME_MINUTES = 15

# Historical candles for warm-up
WARMUP_CANDLES = 200

# Binance endpoints
BINANCE_FUTURES_STREAM = "wss://fstream.binance.com/stream"
BINANCE_FUTURES_API = "https://fapi.binance.com"

# Load environment variables
env_paths = [
    Path(__file__).parent.parent / ".env",
    Path(__file__).parent / ".env",
    Path.cwd() / ".env",
    Path.cwd() / "config" / ".env",
]

for env_path in env_paths:
    if env_path.exists():
        load_dotenv(dotenv_path=env_path)
        break

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)-8s | %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
    handlers=[logging.StreamHandler(sys.stdout)],
)
LOGGER = logging.getLogger("extgap_signal")


def get_workspace_root() -> Path:
    """Get workspace root directory."""
    env_root = os.getenv("WORKSPACE_ROOT")
    if env_root:
        return Path(env_root)

    # Walk up from script directory
    current = Path(__file__).parent.resolve()
    markers = ["requirements.txt", "README.md", ".git"]
    for _ in range(10):
        if any((current / marker).exists() for marker in markers):
            return current
        parent = current.parent
        if parent == current:
            break
        current = parent

    return Path(__file__).parent.parent.parent


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DATA MODELS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


@dataclass(frozen=True)
class Candle:
    """Represents a closed kline."""
    symbol: str
    open_time_ms: int
    close_time_ms: int
    open: float
    high: float
    low: float
    close: float

    @property
    def close_time(self) -> datetime:
        return datetime.fromtimestamp(self.close_time_ms / 1000, tz=timezone.utc)

    @property
    def open_time(self) -> datetime:
        return datetime.fromtimestamp(self.open_time_ms / 1000, tz=timezone.utc)

    @property
    def is_green(self) -> bool:
        return self.close > self.open

    @property
    def is_red(self) -> bool:
        return self.close < self.open

    @property
    def is_doji(self) -> bool:
        return self.close == self.open


@dataclass
class SymbolStatistics:
    """Per-symbol statistics tracking."""
    symbol: str
    wins: int = 0
    losses: int = 0
    nulls: int = 0
    current_win_streak: int = 0
    current_lose_streak: int = 0
    max_win_streak: int = 0
    max_lose_streak: int = 0
    current_signal_polarity: Optional[str] = None
    current_price: float = 0.0
    signal_active: bool = False

    @property
    def total_signals(self) -> int:
        return self.wins + self.losses

    @property
    def win_rate(self) -> float:
        if self.total_signals == 0:
            return 0.0
        return (self.wins / self.total_signals) * 100


@dataclass
class AggregatedStatistics:
    """Combined statistics across all symbols."""
    total_wins: int = 0
    total_losses: int = 0
    total_nulls: int = 0
    current_win_streak: int = 0
    current_lose_streak: int = 0
    max_win_streak: int = 0
    max_lose_streak: int = 0

    @property
    def total_signals(self) -> int:
        return self.total_wins + self.total_losses

    @property
    def win_rate(self) -> float:
        if self.total_signals == 0:
            return 0.0
        return (self.total_wins / self.total_signals) * 100


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# GAP DETECTION STATE (V3 PineScript Algorithm)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


class GapDetectorState:
    """External gap detection using group-based candidate tracking.

    This implementation mirrors the PineScript '[THE] eG v2' algorithm:
    - Maintains a group of all bars since last gap
    - Calculates candidates from group extremes
    - On gap detection: cleans group and recalculates candidates
    """

    def __init__(self, symbol: str):
        self.symbol = symbol

        # Group tracking (all bars since last gap)
        self.group_bar_times: Deque[datetime] = deque(maxlen=500)
        self.group_highs: Deque[float] = deque(maxlen=500)
        self.group_lows: Deque[float] = deque(maxlen=500)

        # Candidate tracking (extremes calculated from group)
        self.bearish_candidate_low: Optional[float] = None
        self.bearish_candidate_idx: Optional[datetime] = None
        self.bullish_candidate_high: Optional[float] = None
        self.bullish_candidate_idx: Optional[datetime] = None

        # Gap tracking
        self.last_gap_polarity: Optional[str] = None
        self.last_gap_level: Optional[float] = None
        self.current_sequence: int = 0

        # Initialization
        self.is_initialized: bool = False

    def add_candle(self, candle: Candle) -> Optional[Dict]:
        """Process candle and detect gaps.

        Returns dict with gap info if detected, None otherwise.
        """
        # Add to group
        self.group_bar_times.append(candle.open_time)
        self.group_highs.append(candle.high)
        self.group_lows.append(candle.low)

        # INITIALIZATION PHASE
        if not self.is_initialized and len(self.group_highs) >= 2:
            max_low = max(self.group_lows)
            min_high = min(self.group_highs)

            bearish_gap = candle.high < max_low
            bullish_gap = candle.low > min_high

            if not (bearish_gap or bullish_gap):
                return None

            is_bearish = bearish_gap
            polarity = "bearish" if is_bearish else "bullish"
            gap_level = max_low if is_bearish else min_high

            # Find gap opening bar
            gap_opening_bar_time = self.group_bar_times[0]
            for i in range(len(self.group_lows) - 1):
                if is_bearish and self.group_lows[i] == max_low:
                    gap_opening_bar_time = self.group_bar_times[i]
                    break
                if not is_bearish and self.group_highs[i] == min_high:
                    gap_opening_bar_time = self.group_bar_times[i]
                    break

            self.last_gap_polarity = polarity
            self.last_gap_level = gap_level
            self.current_sequence = 1

            # Initialize candidates
            self.bearish_candidate_low = candle.low
            self.bearish_candidate_idx = candle.open_time
            self.bullish_candidate_high = candle.high
            self.bullish_candidate_idx = candle.open_time

            for i in range(len(self.group_bar_times)):
                if self.group_bar_times[i] > gap_opening_bar_time:
                    h, l, t = self.group_highs[i], self.group_lows[i], self.group_bar_times[i]
                    if l > self.bearish_candidate_low:
                        self.bearish_candidate_low = l
                        self.bearish_candidate_idx = t
                    if h < self.bullish_candidate_high:
                        self.bullish_candidate_high = h
                        self.bullish_candidate_idx = t

            self.is_initialized = True

            return {
                "polarity": polarity,
                "gap_level": gap_level,
                "is_first_gap": True,
                "is_reversal": False,
                "sequence": self.current_sequence,
            }

        # NORMAL OPERATION
        if self.is_initialized:
            # Update candidates
            if self.bearish_candidate_low is None or candle.low > self.bearish_candidate_low:
                self.bearish_candidate_low = candle.low
                self.bearish_candidate_idx = candle.open_time

            if self.bullish_candidate_high is None or candle.high < self.bullish_candidate_high:
                self.bullish_candidate_high = candle.high
                self.bullish_candidate_idx = candle.open_time

            # Check for gap
            bearish_gap = candle.high < self.bearish_candidate_low
            bullish_gap = candle.low > self.bullish_candidate_high

            if not (bearish_gap or bullish_gap):
                return None

            is_bearish = bearish_gap
            polarity = "bearish" if is_bearish else "bullish"
            gap_level = self.bearish_candidate_low if is_bearish else self.bullish_candidate_high
            gap_opening_bar_time = self.bearish_candidate_idx if is_bearish else self.bullish_candidate_idx

            is_reversal = self.last_gap_polarity is not None and self.last_gap_polarity != polarity

            if is_reversal:
                self.current_sequence = 1
            else:
                self.current_sequence += 1

            prev_polarity = self.last_gap_polarity
            self.last_gap_polarity = polarity
            self.last_gap_level = gap_level

            # Clean group
            while len(self.group_bar_times) > 0 and self.group_bar_times[0] <= gap_opening_bar_time:
                self.group_bar_times.popleft()
                self.group_highs.popleft()
                self.group_lows.popleft()

            # Recalculate candidates
            if len(self.group_highs) > 0:
                self.bearish_candidate_low = max(self.group_lows)
                self.bullish_candidate_high = min(self.group_highs)
                for i in range(len(self.group_lows)):
                    if self.group_lows[i] == self.bearish_candidate_low:
                        self.bearish_candidate_idx = self.group_bar_times[i]
                    if self.group_highs[i] == self.bullish_candidate_high:
                        self.bullish_candidate_idx = self.group_bar_times[i]
            else:
                self.bearish_candidate_low = candle.low
                self.bearish_candidate_idx = candle.open_time
                self.bullish_candidate_high = candle.high
                self.bullish_candidate_idx = candle.open_time

            return {
                "polarity": polarity,
                "gap_level": gap_level,
                "is_first_gap": False,
                "is_reversal": is_reversal,
                "sequence": self.current_sequence,
                "prev_polarity": prev_polarity,
            }

        return None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# STREAK TRACKER WITH PERSISTENCE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


class StreakTracker:
    """Tracks and persists win/loss streaks."""

    def __init__(self, csv_path: Path):
        self.csv_path = csv_path
        self.csv_path.parent.mkdir(parents=True, exist_ok=True)
        self.per_symbol: Dict[str, SymbolStatistics] = {}
        self.aggregated = AggregatedStatistics()
        self.load_max_streaks()

    def load_max_streaks(self):
        """Load max streaks from CSV if exists."""
        if not self.csv_path.exists():
            return

        try:
            with open(self.csv_path, "r") as f:
                lines = f.readlines()
                for line in lines[1:]:  # Skip header
                    parts = line.strip().split(",")
                    if len(parts) >= 3:
                        symbol, max_win, max_lose = parts[0], int(parts[1]), int(parts[2])
                        if symbol == "AGGREGATED":
                            self.aggregated.max_win_streak = max_win
                            self.aggregated.max_lose_streak = max_lose
                        elif symbol in SYMBOLS:
                            if symbol not in self.per_symbol:
                                self.per_symbol[symbol] = SymbolStatistics(symbol=symbol)
                            self.per_symbol[symbol].max_win_streak = max_win
                            self.per_symbol[symbol].max_lose_streak = max_lose
            LOGGER.info(f"Loaded max streaks from {self.csv_path}")
        except Exception as e:
            LOGGER.warning(f"Failed to load streaks: {e}")

    def save_max_streaks(self):
        """Save max streaks to CSV."""
        try:
            with open(self.csv_path, "w") as f:
                f.write("symbol,max_win_streak,max_lose_streak,last_updated\n")
                now = datetime.now(timezone.utc).isoformat()
                for symbol, stats in self.per_symbol.items():
                    f.write(f"{symbol},{stats.max_win_streak},{stats.max_lose_streak},{now}\n")
                f.write(f"AGGREGATED,{self.aggregated.max_win_streak},{self.aggregated.max_lose_streak},{now}\n")
        except Exception as e:
            LOGGER.error(f"Failed to save streaks: {e}")

    def get_or_create_stats(self, symbol: str) -> SymbolStatistics:
        """Get or create stats for symbol."""
        if symbol not in self.per_symbol:
            self.per_symbol[symbol] = SymbolStatistics(symbol=symbol)
        return self.per_symbol[symbol]

    def update_result(self, symbol: str, result: str):
        """Update stats based on result (win/lose/null).

        NULL results don't break streaks and don't count in statistics.
        """
        stats = self.get_or_create_stats(symbol)

        if result == "null":
            stats.nulls += 1
            self.aggregated.total_nulls += 1
            return

        # Update per-symbol stats
        if result == "win":
            stats.wins += 1
            stats.current_win_streak += 1
            stats.current_lose_streak = 0
            stats.max_win_streak = max(stats.max_win_streak, stats.current_win_streak)
        else:  # lose
            stats.losses += 1
            stats.current_lose_streak += 1
            stats.current_win_streak = 0
            stats.max_lose_streak = max(stats.max_lose_streak, stats.current_lose_streak)

        # Update aggregated stats
        if result == "win":
            self.aggregated.total_wins += 1
            self.aggregated.current_win_streak += 1
            self.aggregated.current_lose_streak = 0
            self.aggregated.max_win_streak = max(
                self.aggregated.max_win_streak, self.aggregated.current_win_streak
            )
        else:
            self.aggregated.total_losses += 1
            self.aggregated.current_lose_streak += 1
            self.aggregated.current_win_streak = 0
            self.aggregated.max_lose_streak = max(
                self.aggregated.max_lose_streak, self.aggregated.current_lose_streak
            )

        # Persist max streaks
        self.save_max_streaks()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CSV SIGNAL RECORDER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


class SignalCSVRecorder:
    """Records signals and results to CSV."""

    def __init__(self, csv_path: Path):
        self.csv_path = csv_path
        self.csv_path.parent.mkdir(parents=True, exist_ok=True)

        if not self.csv_path.exists():
            with open(self.csv_path, "w") as f:
                f.write("signal_id,symbol,time,gap_polarity,candle_open,candle_close,result,sequence,is_reversal\n")

    def record(
        self,
        symbol: str,
        time: datetime,
        gap_polarity: str,
        candle_open: float,
        candle_close: float,
        result: str,
        sequence: int,
        is_reversal: bool = False,
    ):
        """Record signal result to CSV."""
        signal_id = str(uuid.uuid4())[:8]
        with open(self.csv_path, "a") as f:
            f.write(
                f"{signal_id},{symbol},{time.isoformat()},{gap_polarity},"
                f"{candle_open:.8f},{candle_close:.8f},{result},{sequence},{is_reversal}\n"
            )


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TELEGRAM NOTIFIER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


class TelegramNotifier:
    """Sends Telegram notifications."""

    def __init__(self, bot_token: str, chat_ids: List[str]):
        self.bot_token = bot_token
        self.chat_ids = chat_ids
        self.base_url = f"https://api.telegram.org/bot{bot_token}"

    @classmethod
    def from_env(cls) -> Optional["TelegramNotifier"]:
        """Load from environment variables."""
        # Try timeframe-specific first
        bot_token = os.getenv("TELEGRAM_BOT_TOKEN_EXTGAP_15M")
        chat_ids_str = os.getenv("TELEGRAM_CHAT_IDS_EXTGAP_15M")

        # Fallback to generic
        if not bot_token:
            bot_token = os.getenv("TELEGRAM_BOT_TOKEN_EXTGAP_DETECTOR")
            chat_ids_str = os.getenv("TELEGRAM_CHAT_IDS_EXTGAP_DETECTOR")

        if not bot_token:
            bot_token = os.getenv("TELEGRAM_BOT_TOKEN")
            chat_ids_str = os.getenv("TELEGRAM_CHAT_IDS")

        if not bot_token or not chat_ids_str:
            LOGGER.warning("Telegram credentials not found")
            return None

        chat_ids = [cid.strip() for cid in chat_ids_str.split(",")]
        return cls(bot_token, chat_ids)

    async def send_message(self, text: str):
        """Send message to all chat IDs."""
        timeout = aiohttp.ClientTimeout(total=10)
        try:
            async with aiohttp.ClientSession(timeout=timeout) as session:
                for chat_id in self.chat_ids:
                    try:
                        await session.post(
                            f"{self.base_url}/sendMessage",
                            json={"chat_id": chat_id, "text": text, "parse_mode": "HTML"},
                        )
                    except Exception as e:
                        LOGGER.error(f"Telegram error for {chat_id}: {e}")
        except Exception as e:
            LOGGER.error(f"Telegram session error: {e}")

    async def notify_startup(self):
        """Send startup notification."""
        instance_id = os.getenv("INSTANCE_ID", "LOCAL")
        symbols_str = ", ".join(SYMBOLS)
        text = (
            f"ğŸš€ <b>EXTGAP SIGNAL BOT STARTED</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"â° {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')} UTC\n"
            f"ğŸ–¥ï¸ Instance: <b>{instance_id}</b>\n"
            f"â±ï¸ Timeframe: <b>{TIMEFRAME}</b>\n"
            f"ğŸ“Š Symbols: <b>{symbols_str}</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"âœ… Monitoring active..."
        )
        await self.send_message(text)

    async def notify_gap_detected(self, symbol: str, polarity: str, gap_level: float, sequence: int):
        """Send gap detection notification."""
        emoji = "ğŸŸ¢" if polarity == "bullish" else "ğŸ”´"
        arrow = "â¬†ï¸" if polarity == "bullish" else "â¬‡ï¸"
        text = (
            f"{emoji} <b>GAP DETECTED - {symbol}</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"â° {datetime.now(timezone.utc).strftime('%H:%M:%S')} UTC\n"
            f"ğŸ“Š Signal: <b>{polarity.upper()} #{sequence}</b> {arrow}\n"
            f"ğŸ’° Gap Level: <b>{gap_level:,.4f}</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"ğŸ”” Tracking candles until reversal..."
        )
        await self.send_message(text)

    async def notify_reversal(self, symbol: str, old_polarity: str, new_polarity: str, gap_level: float):
        """Send reversal notification."""
        old_emoji = "ğŸ”´" if old_polarity == "bearish" else "ğŸŸ¢"
        new_emoji = "ğŸŸ¢" if new_polarity == "bullish" else "ğŸ”´"
        text = (
            f"ğŸ”„ <b>REVERSAL - {symbol}</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"â° {datetime.now(timezone.utc).strftime('%H:%M:%S')} UTC\n"
            f"{old_emoji} {old_polarity.upper()} â†’ {new_emoji} <b>{new_polarity.upper()}</b>\n"
            f"ğŸ’° New Gap Level: <b>{gap_level:,.4f}</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        )
        await self.send_message(text)

    async def notify_candle_result(
        self,
        symbol: str,
        polarity: str,
        result: str,
        candle_open: float,
        candle_close: float,
        stats: SymbolStatistics,
    ):
        """Send candle result notification."""
        if result == "win":
            result_emoji = "âœ…"
            result_text = "WIN"
        elif result == "lose":
            result_emoji = "âŒ"
            result_text = "LOSE"
        else:
            result_emoji = "â–"
            result_text = "NULL (doji)"

        candle_emoji = "ğŸŸ©" if candle_close > candle_open else ("ğŸŸ¥" if candle_close < candle_open else "â¬œ")
        signal_emoji = "â¬†ï¸" if polarity == "bullish" else "â¬‡ï¸"

        streak_text = ""
        if stats.current_win_streak > 0:
            streak_text = f"ğŸ”¥ Win Streak: {stats.current_win_streak}"
        elif stats.current_lose_streak > 0:
            streak_text = f"ğŸ’§ Lose Streak: {stats.current_lose_streak}"

        text = (
            f"{result_emoji} <b>{result_text} - {symbol}</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"â° {datetime.now(timezone.utc).strftime('%H:%M:%S')} UTC\n"
            f"ğŸ“Š Signal: {polarity.upper()} {signal_emoji}\n"
            f"{candle_emoji} O: {candle_open:,.4f} â†’ C: {candle_close:,.4f}\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"ğŸ“ˆ W: {stats.wins} | L: {stats.losses} | N: {stats.nulls}\n"
            f"ğŸ¯ Win Rate: {stats.win_rate:.1f}%\n"
            f"{streak_text}"
        )
        await self.send_message(text)

    async def notify_stats_summary(
        self,
        symbol_stats: Dict[str, SymbolStatistics],
        aggregated: AggregatedStatistics,
    ):
        """Send 15-minute stats summary."""
        now = datetime.now(timezone.utc)

        # Build prices section
        prices_lines = []
        for symbol, stats in symbol_stats.items():
            short_sym = symbol.replace("USDT", "")
            signal_indicator = ""
            if stats.signal_active:
                signal_indicator = "ğŸŸ¢" if stats.current_signal_polarity == "bullish" else "ğŸ”´"
            prices_lines.append(f"  {short_sym}: ${stats.current_price:,.2f} {signal_indicator}")

        prices_text = "\n".join(prices_lines)

        # Build per-symbol stats
        per_symbol_lines = []
        for symbol, stats in symbol_stats.items():
            short_sym = symbol.replace("USDT", "")
            streak = ""
            if stats.current_win_streak > 0:
                streak = f"ğŸ”¥{stats.current_win_streak}W"
            elif stats.current_lose_streak > 0:
                streak = f"ğŸ’§{stats.current_lose_streak}L"
            per_symbol_lines.append(
                f"  {short_sym}: {stats.wins}W/{stats.losses}L ({stats.win_rate:.0f}%) {streak}"
            )

        per_symbol_text = "\n".join(per_symbol_lines)

        # Build max streaks section (per-symbol only)
        max_streaks_lines = []
        for symbol, stats in symbol_stats.items():
            short_sym = symbol.replace("USDT", "")
            max_streaks_lines.append(
                f"  {short_sym}: {stats.max_win_streak}W / {stats.max_lose_streak}L"
            )
        max_streaks_text = "\n".join(max_streaks_lines)

        # Aggregated streak
        agg_streak = ""
        if aggregated.current_win_streak > 0:
            agg_streak = f"ğŸ”¥ Current: {aggregated.current_win_streak} wins"
        elif aggregated.current_lose_streak > 0:
            agg_streak = f"ğŸ’§ Current: {aggregated.current_lose_streak} losses"

        text = (
            f"ğŸ“Š <b>15M STATS SUMMARY</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"â° {now.strftime('%Y-%m-%d %H:%M')} UTC\n\n"
            f"<b>ğŸ’° CURRENT PRICES:</b>\n"
            f"{prices_text}\n\n"
            f"<b>ğŸ“ˆ AGGREGATED:</b>\n"
            f"  W: {aggregated.total_wins} | L: {aggregated.total_losses} | N: {aggregated.total_nulls}\n"
            f"  Win Rate: {aggregated.win_rate:.1f}%\n"
            f"  {agg_streak}\n"
            f"  Max Streaks: {aggregated.max_win_streak}W / {aggregated.max_lose_streak}L\n\n"
            f"<b>ğŸ“‹ PER-SYMBOL:</b>\n"
            f"{per_symbol_text}\n\n"
            f"<b>ğŸ“Š MAX STREAKS:</b>\n"
            f"{max_streaks_text}\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        )
        await self.send_message(text)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN SIGNAL MONITOR
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


class ExtGapSignalMonitor:
    """Main multi-symbol signal monitor."""

    def __init__(self):
        self.workspace_root = get_workspace_root()
        self.data_dir = self.workspace_root / "data" / "signals" / "extgap_signal_15m"
        self.data_dir.mkdir(parents=True, exist_ok=True)

        # Components
        self.gap_detectors: Dict[str, GapDetectorState] = {sym: GapDetectorState(sym) for sym in SYMBOLS}
        self.streak_tracker = StreakTracker(self.data_dir / "streaks.csv")
        self.signal_recorder = SignalCSVRecorder(self.data_dir / "signals.csv")
        self.telegram = TelegramNotifier.from_env()

        # Initialize stats for all symbols
        for symbol in SYMBOLS:
            self.streak_tracker.get_or_create_stats(symbol)

        # WebSocket
        streams = [f"{sym.lower()}@kline_{TIMEFRAME}" for sym in SYMBOLS]
        self.ws_url = f"{BINANCE_FUTURES_STREAM}?streams={'/'.join(streams)}"

        # State
        self.reconnect_delay = 1
        self.max_reconnect_delay = 60
        self.running = True
        self.last_stats_time: Optional[datetime] = None

    async def fetch_historical_candles(self, symbol: str, limit: int = 200) -> List[Candle]:
        """Fetch historical candles for warm-up."""
        url = f"{BINANCE_FUTURES_API}/fapi/v1/klines"
        params = {"symbol": symbol, "interval": TIMEFRAME, "limit": limit}

        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, params=params) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        candles = []
                        for k in data[:-1]:  # Skip incomplete last candle
                            candles.append(
                                Candle(
                                    symbol=symbol,
                                    open_time_ms=k[0],
                                    close_time_ms=k[6],
                                    open=float(k[1]),
                                    high=float(k[2]),
                                    low=float(k[3]),
                                    close=float(k[4]),
                                )
                            )
                        return candles
                    else:
                        LOGGER.error(f"Failed to fetch {symbol} history: {resp.status}")
                        return []
        except Exception as e:
            LOGGER.error(f"Error fetching {symbol} history: {e}")
            return []

    async def warm_up(self):
        """Warm up gap detectors with historical data."""
        LOGGER.info(f"Warming up with {WARMUP_CANDLES} candles per symbol...")

        tasks = [self.fetch_historical_candles(sym, WARMUP_CANDLES) for sym in SYMBOLS]
        results = await asyncio.gather(*tasks)

        for symbol, candles in zip(SYMBOLS, results):
            detector = self.gap_detectors[symbol]
            gaps_found = 0
            for candle in candles:
                gap = detector.add_candle(candle)
                if gap:
                    gaps_found += 1
                    # Update signal state
                    stats = self.streak_tracker.get_or_create_stats(symbol)
                    stats.signal_active = True
                    stats.current_signal_polarity = gap["polarity"]
                stats = self.streak_tracker.get_or_create_stats(symbol)
                stats.current_price = candle.close

            LOGGER.info(f"{symbol}: Processed {len(candles)} candles, {gaps_found} gaps detected")

    def evaluate_candle(self, symbol: str, candle: Candle) -> Optional[str]:
        """Evaluate candle against active signal.

        Returns 'win', 'lose', 'null', or None if no active signal.
        """
        stats = self.streak_tracker.get_or_create_stats(symbol)

        if not stats.signal_active or not stats.current_signal_polarity:
            return None

        if candle.is_doji:
            return "null"

        polarity = stats.current_signal_polarity

        if polarity == "bullish":
            return "win" if candle.is_green else "lose"
        else:  # bearish
            return "win" if candle.is_red else "lose"

    async def process_candle(self, symbol: str, candle: Candle):
        """Process a closed candle for a symbol.

        IMPORTANT: The order of operations matters!
        1. First, evaluate the candle against the CURRENT active signal (before any gap detection)
        2. Then, detect gaps and update the signal polarity

        This ensures that when a reversal happens, the candle that triggered the reversal
        is evaluated against the OLD polarity (the one that was active when the candle opened).
        """
        stats = self.streak_tracker.get_or_create_stats(symbol)
        stats.current_price = candle.close

        # STEP 1: Evaluate current candle against the CURRENT active signal BEFORE gap detection
        # This ensures reversals are counted correctly - the candle is judged by the signal
        # that was active when it opened, not the new signal it triggers
        polarity_for_evaluation = stats.current_signal_polarity
        result = self.evaluate_candle(symbol, candle)

        # STEP 2: Now check for gap detection (this may change the signal polarity)
        detector = self.gap_detectors[symbol]
        gap = detector.add_candle(candle)

        if gap:
            polarity = gap["polarity"]
            is_reversal = gap.get("is_reversal", False)
            is_first = gap.get("is_first_gap", False)

            if is_reversal and self.telegram:
                prev_polarity = gap.get("prev_polarity", "bullish" if polarity == "bearish" else "bearish")
                await self.telegram.notify_reversal(symbol, prev_polarity, polarity, gap["gap_level"])

            if is_first or is_reversal:
                # New signal starts - update polarity AFTER evaluation
                stats.signal_active = True
                stats.current_signal_polarity = polarity
                if self.telegram:
                    await self.telegram.notify_gap_detected(symbol, polarity, gap["gap_level"], gap["sequence"])

            elif not is_reversal:
                # Same direction gap (continuation)
                if self.telegram:
                    await self.telegram.notify_gap_detected(symbol, polarity, gap["gap_level"], gap["sequence"])

            LOGGER.info(
                f"{symbol}: {'REVERSAL' if is_reversal else ('FIRST' if is_first else 'CONTINUATION')} "
                f"{polarity.upper()} gap #{gap['sequence']} at {gap['gap_level']:.4f}"
            )

        # STEP 3: Now report the result (using the polarity that was active BEFORE the gap detection)
        if result is not None:
            # Update stats
            self.streak_tracker.update_result(symbol, result)

            # Record to CSV - use the polarity that was active when candle was evaluated
            self.signal_recorder.record(
                symbol=symbol,
                time=candle.close_time,
                gap_polarity=polarity_for_evaluation or "unknown",
                candle_open=candle.open,
                candle_close=candle.close,
                result=result,
                sequence=detector.current_sequence,
                is_reversal=gap["is_reversal"] if gap else False,
            )

            # Send result notification - use the polarity that was active when candle was evaluated
            if self.telegram:
                await self.telegram.notify_candle_result(
                    symbol=symbol,
                    polarity=polarity_for_evaluation or "unknown",
                    result=result,
                    candle_open=candle.open,
                    candle_close=candle.close,
                    stats=stats,
                )

            LOGGER.info(
                f"{symbol}: {result.upper()} | "
                f"O:{candle.open:.4f} C:{candle.close:.4f} | "
                f"Streak: W{stats.current_win_streak}/L{stats.current_lose_streak}"
            )

    async def check_stats_time(self, candle: Candle):
        """Check if it's time to send stats summary.

        Stats are sent every 15 minutes when a candle closes.
        Since candle close_time is 11:29:59.999 for the 11:15-11:30 candle,
        we use open_time + 15 minutes as the boundary check.
        """
        # The candle that just closed represents the period ending at open_time + 15m
        boundary_time = candle.open_time + timedelta(minutes=TIMEFRAME_MINUTES)
        boundary_minutes = boundary_time.minute

        # Check if this is a 15m stats boundary (0, 15, 30, 45)
        is_stats_boundary = boundary_minutes % 15 == 0

        if not is_stats_boundary:
            return

        if self.last_stats_time is not None:
            time_diff = (boundary_time - self.last_stats_time).total_seconds()
            if time_diff < 14 * 60:  # Less than 14 minutes since last stats
                return

        self.last_stats_time = boundary_time
        LOGGER.info(f"Sending 15m stats summary at {boundary_time.strftime('%H:%M')} UTC")

        if self.telegram:
            await self.telegram.notify_stats_summary(
                self.streak_tracker.per_symbol, self.streak_tracker.aggregated
            )

    async def handle_message(self, message: str):
        """Handle WebSocket message."""
        try:
            data = json.loads(message)

            # Combined stream format: {"stream": "btcusdt@kline_15m", "data": {...}}
            if "stream" in data:
                stream_data = data["data"]
            else:
                stream_data = data

            if stream_data.get("e") != "kline":
                return

            k = stream_data["k"]
            if not k.get("x"):  # Not closed
                return

            symbol = k["s"]
            candle = Candle(
                symbol=symbol,
                open_time_ms=k["t"],
                close_time_ms=k["T"],
                open=float(k["o"]),
                high=float(k["h"]),
                low=float(k["l"]),
                close=float(k["c"]),
            )

            LOGGER.debug(f"{symbol}: Candle closed at {candle.close_time} | C:{candle.close:.4f}")

            await self.process_candle(symbol, candle)

            # Check if time for stats summary
            await self.check_stats_time(candle)

        except json.JSONDecodeError as e:
            LOGGER.error(f"JSON decode error: {e}")
        except Exception as e:
            LOGGER.error(f"Error handling message: {e}", exc_info=True)

    async def websocket_loop(self):
        """Main WebSocket loop with reconnection."""
        while self.running:
            try:
                LOGGER.info(f"Connecting to WebSocket: {self.ws_url[:80]}...")
                async with websockets.connect(self.ws_url) as ws:
                    LOGGER.info("âœ… WebSocket connected")
                    self.reconnect_delay = 1

                    async for message in ws:
                        if not self.running:
                            break
                        await self.handle_message(message)

            except websockets.exceptions.ConnectionClosedError as e:
                LOGGER.warning(f"WebSocket closed: {e}")
            except Exception as e:
                LOGGER.error(f"WebSocket error: {e}")

            if self.running:
                LOGGER.info(f"Reconnecting in {self.reconnect_delay}s...")
                await asyncio.sleep(self.reconnect_delay)
                self.reconnect_delay = min(self.reconnect_delay * 2, self.max_reconnect_delay)

    async def run(self):
        """Main entry point."""
        LOGGER.info("=" * 60)
        LOGGER.info("ExtGap Signal Monitor - Multi-Symbol 15m")
        LOGGER.info("=" * 60)
        LOGGER.info(f"Symbols: {', '.join(SYMBOLS)}")
        LOGGER.info(f"Timeframe: {TIMEFRAME}")
        LOGGER.info(f"Data dir: {self.data_dir}")
        LOGGER.info("=" * 60)

        # Warm up
        await self.warm_up()

        # Send startup notification
        if self.telegram:
            await self.telegram.notify_startup()
            LOGGER.info("âœ… Telegram startup notification sent")
        else:
            LOGGER.warning("âš ï¸ Telegram not configured")

        # Start WebSocket loop
        await self.websocket_loop()

    def stop(self):
        """Stop the monitor."""
        LOGGER.info("Stopping monitor...")
        self.running = False


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


async def main():
    """Main entry point."""
    monitor = ExtGapSignalMonitor()

    # Handle shutdown signals
    def handle_shutdown(signum, frame):
        LOGGER.info(f"Received signal {signum}, shutting down...")
        monitor.stop()

    signal.signal(signal.SIGINT, handle_shutdown)
    signal.signal(signal.SIGTERM, handle_shutdown)

    try:
        await monitor.run()
    except Exception as e:
        LOGGER.error(f"Fatal error: {e}", exc_info=True)
    finally:
        LOGGER.info("Monitor stopped")


if __name__ == "__main__":
    asyncio.run(main())
