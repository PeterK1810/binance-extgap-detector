#!/usr/bin/env python3
"""
Binance External Gap Detector - Version 3 (PineScript Algorithm)
==================================================================

Production-ready gap detector with PineScript "[THE] eG v2" algorithm.

Features:
- Group-based candidate tracking (exact PineScript port)
- Candle synchronization validation (timeframe boundary alignment)
- Sequence numbering in Telegram messages (#1, #2, reversals)
- Interactive parameter prompts (symbol, timeframe, stats interval)
- Configurable stats notifications (10m, 30m, 1h, 2h, 4h, etc.)
- CSV logging with sequence tracking
- Real-time Binance Futures WebSocket

Author: Generated by Claude Code
Date: 2025-11-14
"""

import asyncio
import json
import logging
import os
import sys
from collections import deque
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from pathlib import Path
from typing import Optional, Deque

import websockets
import aiohttp
from dotenv import load_dotenv

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DEFAULT_OUTPUT_DIR = "data"
DEFAULT_LOG_DIR = "logs"

# Load environment variables from parent directory
parent_env = Path(__file__).parent.parent / ".env"
if parent_env.exists():
    load_dotenv(parent_env)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# HELPER FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def parse_interval_minutes(interval: str) -> int:
    """
    Convert interval string to minutes.

    Examples:
        '30m' -> 30
        '2h' -> 120
        '1d' -> 1440
    """
    interval = interval.strip().lower()

    if interval.endswith('m'):
        return int(interval[:-1])
    elif interval.endswith('h'):
        return int(interval[:-1]) * 60
    elif interval.endswith('d'):
        return int(interval[:-1]) * 1440
    else:
        raise ValueError(f"Invalid interval format: {interval}. Use: 10m, 1h, 4h, etc.")


def get_workspace_root(script_path: Path) -> Path:
    """
    Find workspace root directory robustly.
    
    Looks for marker files (requirements.txt, README.md, .git) by walking up
    the directory tree from the script location. Falls back to script_dir.parent.parent
    if markers not found. Can also use WORKSPACE_ROOT environment variable.
    
    Args:
        script_path: Path to the current script file
        
    Returns:
        Path to workspace root directory
    """
    import os
    # Check environment variable first
    env_root = os.getenv("WORKSPACE_ROOT")
    if env_root:
        root_path = Path(env_root)
        if root_path.exists() and root_path.is_dir():
            return root_path.resolve()
    
    # Walk up from script directory looking for marker files
    current = script_path.parent.resolve()
    markers = ["requirements.txt", "README.md", ".git"]
    max_depth = 10  # Prevent infinite loops
    
    for _ in range(max_depth):
        # Check if any marker file exists in current directory
        if any((current / marker).exists() for marker in markers):
            return current
        # Stop at filesystem root
        parent = current.parent
        if parent == current:
            break
        current = parent
    
    # Fallback: assume script is at bots/detectors/ or bots/indicators/
    # This maintains backward compatibility
    script_dir = script_path.parent
    return script_dir.parent.parent


def is_candle_aligned(open_time: datetime, timeframe_minutes: int) -> bool:
    """
    Check if candle open time aligns to timeframe boundary.

    Examples:
        For 2m timeframe: 10:00, 10:02, 10:04 are aligned
        For 1h timeframe: 10:00, 11:00, 12:00 are aligned
    """
    timestamp_ms = int(open_time.timestamp() * 1000)
    timeframe_ms = timeframe_minutes * 60 * 1000
    return (timestamp_ms % timeframe_ms) == 0


def prompt_configuration() -> dict:
    """Interactive prompts for all parameters"""

    print()
    print("=" * 70)
    print("  Binance External Gap Detector v3 - Configuration")
    print("  PineScript '[THE] eG v2' Algorithm")
    print("=" * 70)
    print()

    # Symbol selection
    print("ğŸ“Š SYMBOL")
    print("   Available: BTCUSDT, ETHUSDT, SOLUSDT, BNBUSDT, etc.")
    symbol = input("   Enter symbol [BTCUSDT]: ").strip().upper() or "BTCUSDT"

    # Timeframe selection
    print()
    print("â° TIMEFRAME")
    print("   Available: 1m, 2m, 3m, 5m, 15m, 30m, 1h, 4h, 1d")
    timeframe = input("   Enter timeframe [2m]: ").strip().lower() or "2m"

    # Stats notification interval
    print()
    print("ğŸ“ˆ STATISTICS NOTIFICATION INTERVAL")
    print("   Examples: 10m, 30m, 1h, 2h, 4h, 6h, 12h, 1d")
    stats_interval = input("   Enter interval [1h]: ").strip().lower() or "1h"

    # Validate intervals
    try:
        timeframe_minutes = parse_interval_minutes(timeframe)
        stats_interval_minutes = parse_interval_minutes(stats_interval)
    except ValueError as e:
        print(f"\nâŒ Error: {e}")
        sys.exit(1)

    # Configuration summary
    print()
    print("=" * 70)
    print("  CONFIGURATION SUMMARY")
    print("=" * 70)
    print(f"  Symbol:          {symbol}")
    print(f"  Timeframe:       {timeframe} ({timeframe_minutes} minutes)")
    print(f"  Stats interval:  {stats_interval} ({stats_interval_minutes} minutes)")
    print("=" * 70)
    print()

    # Confirmation
    confirm = input("Proceed with these settings? [Y/n]: ").strip().lower()
    if confirm and confirm != 'y':
        print("\nâŒ Configuration cancelled by user.")
        sys.exit(0)

    print()
    return {
        "symbol": symbol,
        "timeframe": timeframe,
        "timeframe_minutes": timeframe_minutes,
        "stats_interval": stats_interval,
        "stats_interval_minutes": stats_interval_minutes
    }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DATA MODELS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class Candle:
    """Closed kline data from Binance"""
    symbol: str
    open_time: datetime
    close_time: datetime
    open: float
    high: float
    low: float
    close: float
    volume: float

    @classmethod
    def from_websocket(cls, symbol: str, kline_data: dict) -> 'Candle':
        """Parse candle from Binance WebSocket kline event"""
        return cls(
            symbol=symbol,
            open_time=datetime.fromtimestamp(kline_data['t'] / 1000, tz=timezone.utc),
            close_time=datetime.fromtimestamp(kline_data['T'] / 1000, tz=timezone.utc),
            open=float(kline_data['o']),
            high=float(kline_data['h']),
            low=float(kline_data['l']),
            close=float(kline_data['c']),
            volume=float(kline_data['v'])
        )


@dataclass
class ExternalGap:
    """External gap detection event"""
    detected_at: datetime
    symbol: str
    polarity: str  # "bullish" or "bearish"
    gap_level: float
    gap_opening_bar_time: datetime
    detection_bar_time: datetime
    is_first_gap: bool
    is_reversal: bool
    sequence_number: int
    group_size_before_cleanup: int
    detection_candle_close: float  # Close price of candle that triggered detection
    trade_result: Optional['TradeResult'] = None  # Profit from closed position if reversal


@dataclass
class TradeResult:
    """Trade result with profit calculation"""
    close_time: datetime
    symbol: str
    closed_side: str  # "LONG" or "SHORT"
    entry_price: float
    exit_price: float
    entry_time: datetime
    notional_usd: float
    quantity: float
    gross_pnl: float
    pnl_percent: float
    reversal_to: str  # "LONG" or "SHORT" - new position opened
    closed_sequence: int
    opened_sequence: int


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# GROUP-BASED GAP DETECTION STATE (PineScript Algorithm)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class GapDetectorState:
    """
    External gap detection using group-based candidate tracking.

    This implementation mirrors the PineScript '[THE] eG v2' algorithm:
    - Maintains a group of all bars since last gap
    - Calculates candidates from group extremes
    - On gap detection: cleans group and recalculates candidates
    """

    def __init__(self, symbol: str, stats_interval_minutes: int):
        self.symbol = symbol
        self.stats_interval_minutes = stats_interval_minutes

        # Group tracking (all bars since last gap)
        self.group_bar_times: Deque[datetime] = deque(maxlen=500)
        self.group_highs: Deque[float] = deque(maxlen=500)
        self.group_lows: Deque[float] = deque(maxlen=500)

        # Candidate tracking (extremes calculated from group)
        self.bearish_candidate_low: Optional[float] = None  # Highest low in group
        self.bearish_candidate_idx: Optional[datetime] = None
        self.bullish_candidate_high: Optional[float] = None  # Lowest high in group
        self.bullish_candidate_idx: Optional[datetime] = None

        # Gap tracking
        self.last_gap_time: Optional[datetime] = None
        self.last_gap_level: Optional[float] = None
        self.last_gap_polarity: Optional[str] = None
        self.last_gap_opening_time: Optional[datetime] = None

        # Initialization state
        self.is_initialized: bool = False

        # Sequence tracking
        self.current_sequence_number: int = 0

        # Statistics
        self.total_gaps: int = 0
        self.bullish_gaps: int = 0
        self.bearish_gaps: int = 0
        self.reversals: int = 0
        self.last_stats_time: Optional[datetime] = None

        # Profit tracking
        self.last_entry_price: Optional[float] = None
        self.last_entry_side: Optional[str] = None  # "LONG" or "SHORT"
        self.last_entry_time: Optional[datetime] = None
        self.last_entry_sequence: int = 0

        # Cumulative statistics
        self.cumulative_pnl: float = 0.0
        self.total_trades: int = 0
        self.winning_trades: int = 0
        self.losing_trades: int = 0

        # Additional cumulative tracking
        self.cumulative_volume_usd: float = 0.0  # Total notional traded
        self.bot_start_time: datetime = datetime.now(timezone.utc)  # Bot launch timestamp
        self.sum_winning_pnl: float = 0.0  # Sum of all winning trades P&L
        self.sum_losing_pnl: float = 0.0   # Sum of all losing trades P&L (will be negative)

    def add_candle(self, candle: Candle) -> Optional[ExternalGap]:
        """
        Process new closed candle and detect external gaps.

        Algorithm mirrors PineScript '[THE] eG v2':
        1. Add candle to group arrays
        2. If not initialized: find first gap using group extremes
        3. If initialized: check gap against candidates, then clean group and recalculate

        Returns:
            ExternalGap if gap detected, None otherwise
        """
        # Add current bar to group
        self.group_bar_times.append(candle.open_time)
        self.group_highs.append(candle.high)
        self.group_lows.append(candle.low)

        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # INITIALIZATION PHASE: Detect first gap using group extremes
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        if not self.is_initialized and len(self.group_highs) >= 2:
            # Find group extremes
            max_low = max(self.group_lows)
            min_high = min(self.group_highs)

            # Check if current bar creates a gap
            bearish_gap = candle.high < max_low
            bullish_gap = candle.low > min_high

            if not (bearish_gap or bullish_gap):
                return None

            # Gap detected! Initialize system
            is_bearish = bearish_gap
            polarity = "bearish" if is_bearish else "bullish"
            gap_level = max_low if is_bearish else min_high

            # Find which bar created the gap level
            gap_opening_bar_time = None
            for i in range(len(self.group_lows) - 1):
                if is_bearish and self.group_lows[i] == max_low:
                    gap_opening_bar_time = self.group_bar_times[i]
                    break
                if not is_bearish and self.group_highs[i] == min_high:
                    gap_opening_bar_time = self.group_bar_times[i]
                    break

            if gap_opening_bar_time is None:
                gap_opening_bar_time = self.group_bar_times[0]

            # Update gap tracking
            self.last_gap_time = candle.close_time
            self.last_gap_level = gap_level
            self.last_gap_polarity = polarity
            self.last_gap_opening_time = gap_opening_bar_time

            # Initialize sequence
            self.current_sequence_number = 1

            # Update statistics
            self.total_gaps += 1
            if is_bearish:
                self.bearish_gaps += 1
            else:
                self.bullish_gaps += 1

            # Initialize candidates from bars AFTER gap opening bar
            self.bearish_candidate_low = candle.low
            self.bearish_candidate_idx = candle.open_time
            self.bullish_candidate_high = candle.high
            self.bullish_candidate_idx = candle.open_time

            for i in range(len(self.group_bar_times)):
                if self.group_bar_times[i] > gap_opening_bar_time:
                    h = self.group_highs[i]
                    l = self.group_lows[i]
                    t = self.group_bar_times[i]

                    if l > self.bearish_candidate_low:
                        self.bearish_candidate_low = l
                        self.bearish_candidate_idx = t

                    if h < self.bullish_candidate_high:
                        self.bullish_candidate_high = h
                        self.bullish_candidate_idx = t

            self.is_initialized = True

            # Update entry tracking for first gap
            new_side = "LONG" if polarity == "bullish" else "SHORT"
            self.last_entry_price = candle.close
            self.last_entry_side = new_side
            self.last_entry_time = candle.close_time
            self.last_entry_sequence = self.current_sequence_number

            return ExternalGap(
                detected_at=datetime.now(timezone.utc),
                symbol=self.symbol,
                polarity=polarity,
                gap_level=gap_level,
                gap_opening_bar_time=gap_opening_bar_time,
                detection_bar_time=candle.close_time,
                is_first_gap=True,
                is_reversal=False,
                sequence_number=self.current_sequence_number,
                group_size_before_cleanup=0,
                detection_candle_close=candle.close,
                trade_result=None  # No previous position on first gap
            )

        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # NORMAL OPERATION: Check gap against candidates
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        if self.is_initialized:
            # Update candidates if current bar has more extreme values
            if candle.low > self.bearish_candidate_low:
                self.bearish_candidate_low = candle.low
                self.bearish_candidate_idx = candle.open_time

            if candle.high < self.bullish_candidate_high:
                self.bullish_candidate_high = candle.high
                self.bullish_candidate_idx = candle.open_time

            # Check for new gap
            bearish_gap = candle.high < self.bearish_candidate_low
            bullish_gap = candle.low > self.bullish_candidate_high

            if not (bearish_gap or bullish_gap):
                return None

            # Gap detected!
            is_bearish = bearish_gap
            polarity = "bearish" if is_bearish else "bullish"
            gap_level = self.bearish_candidate_low if is_bearish else self.bullish_candidate_high
            gap_opening_bar_time = self.bearish_candidate_idx if is_bearish else self.bullish_candidate_idx

            # Check if reversal
            is_reversal = self.last_gap_polarity is not None and self.last_gap_polarity != polarity

            # Calculate profit for previous position if reversal
            trade_result = None
            if is_reversal:
                self.current_sequence_number = 1  # Reset sequence
                self.reversals += 1

                # Calculate P&L if we have a previous entry
                if self.last_entry_price is not None:
                    # Determine closed side (opposite of new polarity)
                    closed_side = "SHORT" if polarity == "bullish" else "LONG"

                    # Calculate P&L with fixed $1000 notional
                    notional = 1000.0
                    quantity = notional / self.last_entry_price

                    if closed_side == "SHORT":
                        # Profit on short: entry - exit
                        gross_pnl = (self.last_entry_price - candle.close) * quantity
                    else:  # LONG
                        # Profit on long: exit - entry
                        gross_pnl = (candle.close - self.last_entry_price) * quantity

                    pnl_percent = (gross_pnl / notional) * 100

                    # Update cumulative stats
                    self.cumulative_pnl += gross_pnl
                    self.total_trades += 1
                    if gross_pnl > 0:
                        self.winning_trades += 1
                        self.sum_winning_pnl += gross_pnl
                    else:
                        self.losing_trades += 1
                        self.sum_losing_pnl += gross_pnl  # gross_pnl is negative for losses

                    # Track cumulative volume (notional USD of closed position)
                    self.cumulative_volume_usd += notional  # notional is 1000.0

                    # Create TradeResult
                    trade_result = TradeResult(
                        close_time=candle.close_time,
                        symbol=self.symbol,
                        closed_side=closed_side,
                        entry_price=self.last_entry_price,
                        exit_price=candle.close,
                        entry_time=self.last_entry_time,
                        notional_usd=notional,
                        quantity=quantity,
                        gross_pnl=gross_pnl,
                        pnl_percent=pnl_percent,
                        reversal_to="LONG" if polarity == "bullish" else "SHORT",
                        closed_sequence=self.last_entry_sequence,
                        opened_sequence=self.current_sequence_number
                    )

                # Update entry tracking for new position (always on reversal)
                new_side = "LONG" if polarity == "bullish" else "SHORT"
                self.last_entry_price = candle.close
                self.last_entry_side = new_side
                self.last_entry_time = candle.close_time
                self.last_entry_sequence = self.current_sequence_number
            else:
                # Same polarity - DON'T update entry tracking
                self.current_sequence_number += 1  # Increment sequence

            # Store group size before cleanup (for analysis)
            group_size_before = len(self.group_bar_times)

            # Update gap tracking
            self.last_gap_time = candle.close_time
            self.last_gap_level = gap_level
            self.last_gap_polarity = polarity
            self.last_gap_opening_time = gap_opening_bar_time

            # Update statistics
            self.total_gaps += 1
            if is_bearish:
                self.bearish_gaps += 1
            else:
                self.bullish_gaps += 1

            # Clean up group: remove bars <= gap opening bar
            while len(self.group_bar_times) > 0 and self.group_bar_times[0] <= gap_opening_bar_time:
                self.group_bar_times.popleft()
                self.group_highs.popleft()
                self.group_lows.popleft()

            # Recalculate candidates from remaining group
            if len(self.group_highs) > 0:
                self.bearish_candidate_low = max(self.group_lows)
                self.bullish_candidate_high = min(self.group_highs)

                # Find indices of candidates
                for i in range(len(self.group_lows)):
                    if self.group_lows[i] == self.bearish_candidate_low:
                        self.bearish_candidate_idx = self.group_bar_times[i]
                    if self.group_highs[i] == self.bullish_candidate_high:
                        self.bullish_candidate_idx = self.group_bar_times[i]
            else:
                # Group is empty, use current candle
                self.bearish_candidate_low = candle.low
                self.bearish_candidate_idx = candle.open_time
                self.bullish_candidate_high = candle.high
                self.bullish_candidate_idx = candle.open_time

            return ExternalGap(
                detected_at=datetime.now(timezone.utc),
                symbol=self.symbol,
                polarity=polarity,
                gap_level=gap_level,
                gap_opening_bar_time=gap_opening_bar_time,
                detection_bar_time=candle.close_time,
                is_first_gap=False,
                is_reversal=is_reversal,
                sequence_number=self.current_sequence_number,
                group_size_before_cleanup=group_size_before,
                detection_candle_close=candle.close,
                trade_result=trade_result
            )

        return None

    def should_send_stats(self, current_time: datetime) -> bool:
        """Check if stats should be sent based on configured interval"""
        if self.last_stats_time is None:
            self.last_stats_time = current_time
            return False

        elapsed_minutes = (current_time - self.last_stats_time).total_seconds() / 60

        if elapsed_minutes >= self.stats_interval_minutes:
            self.last_stats_time = current_time
            return True

        return False

    def get_stats(self) -> dict:
        """Get current statistics"""
        avg_frequency_min = None
        if self.total_gaps > 1 and len(self.group_bar_times) > 0:
            first_time = self.group_bar_times[0]
            last_time = self.group_bar_times[-1]
            elapsed = (last_time - first_time).total_seconds() / 60
            avg_frequency_min = elapsed / self.total_gaps if self.total_gaps > 0 else None

        # Calculate bot uptime in minutes
        uptime_minutes = (datetime.now(timezone.utc) - self.bot_start_time).total_seconds() / 60

        # Calculate average winning/losing trades (handle division by zero)
        avg_winning_trade = self.sum_winning_pnl / self.winning_trades if self.winning_trades > 0 else 0.0
        avg_losing_trade = self.sum_losing_pnl / self.losing_trades if self.losing_trades > 0 else 0.0

        return {
            "total_gaps": self.total_gaps,
            "bullish_gaps": self.bullish_gaps,
            "bearish_gaps": self.bearish_gaps,
            "reversals": self.reversals,
            "current_trend": self.last_gap_polarity or "N/A",
            "current_sequence": self.current_sequence_number,
            "avg_frequency_min": avg_frequency_min,
            "cumulative_pnl": self.cumulative_pnl,
            "total_trades": self.total_trades,
            "winning_trades": self.winning_trades,
            "losing_trades": self.losing_trades,
            "win_rate": (self.winning_trades / self.total_trades * 100) if self.total_trades > 0 else 0,
            # NEW METRICS
            "cumulative_volume_usd": self.cumulative_volume_usd,
            "uptime_minutes": uptime_minutes,
            "avg_winning_trade": avg_winning_trade,
            "avg_losing_trade": avg_losing_trade
        }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CSV RECORDER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class GapCSVRecorder:
    """Records gap detections to CSV file"""

    def __init__(self, output_path: Path):
        self.output_path = output_path
        self.output_path.parent.mkdir(parents=True, exist_ok=True)

        # Create file with headers if doesn't exist
        if not self.output_path.exists():
            with open(self.output_path, 'w') as f:
                f.write("detected_at_utc,symbol,polarity,gap_level,gap_opening_bar_time,"
                       "detection_bar_time,is_first_gap,is_reversal,sequence_number,group_size_before_cleanup\n")

    def record_gap(self, gap: ExternalGap):
        """Append gap detection to CSV"""
        with open(self.output_path, 'a') as f:
            f.write(f"{gap.detected_at.isoformat()},"
                   f"{gap.symbol},"
                   f"{gap.polarity},"
                   f"{gap.gap_level:.2f},"
                   f"{gap.gap_opening_bar_time.isoformat()},"
                   f"{gap.detection_bar_time.isoformat()},"
                   f"{gap.is_first_gap},"
                   f"{gap.is_reversal},"
                   f"{gap.sequence_number},"
                   f"{gap.group_size_before_cleanup}\n")


class TradeCSVRecorder:
    """Records trade results to CSV file"""

    def __init__(self, output_path: Path):
        self.output_path = output_path
        self.output_path.parent.mkdir(parents=True, exist_ok=True)

        # Create file with headers if doesn't exist
        if not self.output_path.exists():
            with open(self.output_path, 'w') as f:
                f.write("close_time,symbol,closed_side,entry_price,exit_price,entry_time,"
                       "notional_usd,quantity,gross_pnl,pnl_percent,reversal_to,"
                       "closed_sequence,opened_sequence,cumulative_pnl,total_trades,win_rate\n")

    def record_trade(self, trade: TradeResult, cumulative_pnl: float,
                     total_trades: int, winning_trades: int):
        """Append trade result to CSV"""
        win_rate = (winning_trades / total_trades * 100) if total_trades > 0 else 0
        with open(self.output_path, 'a') as f:
            f.write(f"{trade.close_time.isoformat()},"
                   f"{trade.symbol},"
                   f"{trade.closed_side},"
                   f"{trade.entry_price:.2f},"
                   f"{trade.exit_price:.2f},"
                   f"{trade.entry_time.isoformat()},"
                   f"{trade.notional_usd:.2f},"
                   f"{trade.quantity:.8f},"
                   f"{trade.gross_pnl:.2f},"
                   f"{trade.pnl_percent:.2f},"
                   f"{trade.reversal_to},"
                   f"{trade.closed_sequence},"
                   f"{trade.opened_sequence},"
                   f"{cumulative_pnl:.2f},"
                   f"{total_trades},"
                   f"{win_rate:.2f}\n")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TELEGRAM NOTIFIER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class TelegramNotifier:
    """Send rich Telegram notifications with sequence numbering"""

    def __init__(self, bot_token: str, chat_ids: list[str]):
        self.bot_token = bot_token
        self.chat_ids = chat_ids
        self.base_url = f"https://api.telegram.org/bot{bot_token}"

    @classmethod
    def from_env(cls) -> Optional['TelegramNotifier']:
        """Load from environment variables"""
        bot_token = os.getenv("TELEGRAM_BOT_TOKEN_EXTGAP_DETECTOR")
        chat_ids_str = os.getenv("TELEGRAM_CHAT_IDS_EXTGAP_DETECTOR")

        if not bot_token or not chat_ids_str:
            logging.warning("Telegram credentials not found in environment")
            return None

        chat_ids = [cid.strip() for cid in chat_ids_str.split(',')]
        return cls(bot_token, chat_ids)

    async def send_message(self, text: str):
        """Send message to all configured chat IDs"""
        async with aiohttp.ClientSession() as session:
            for chat_id in self.chat_ids:
                try:
                    await session.post(
                        f"{self.base_url}/sendMessage",
                        json={"chat_id": chat_id, "text": text, "parse_mode": "HTML"}
                    )
                except Exception as e:
                    logging.error(f"Failed to send Telegram message to {chat_id}: {e}")

    async def notify_first_gap(self, gap: ExternalGap):
        """Notification for first gap detected (initialization)"""
        emoji = "â¬†ï¸" if gap.polarity == "bullish" else "â¬‡ï¸"
        text = (
            f"ğŸš€ <b>PREMIER GAP DÃ‰TECTÃ‰ - {gap.symbol}</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"â° {gap.detection_bar_time.strftime('%H:%M:%S')} UTC\n"
            f"ğŸ“Š PolaritÃ©: <b>{gap.polarity.upper()} #{gap.sequence_number}</b> {emoji}\n"
            f"ğŸ’° Niveau: <b>{gap.gap_level:,.2f} USDT</b>\n"
            f"ğŸ•’ Barre ouverture: {gap.gap_opening_bar_time.strftime('%H:%M:%S')}\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"âš ï¸ Pas de trade - attente inversion"
        )
        await self.send_message(text)

    async def notify_gap(self, gap: ExternalGap):
        """Notification for normal gap (same polarity)"""
        emoji = "â¬†ï¸" if gap.polarity == "bullish" else "â¬‡ï¸"
        text = (
            f"ğŸ“Š <b>GAP {gap.polarity.upper()} #{gap.sequence_number} DÃ‰TECTÃ‰ - {gap.symbol}</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"â° {gap.detection_bar_time.strftime('%H:%M:%S')} UTC\n"
            f"ğŸ’° Niveau: <b>{gap.gap_level:,.2f} USDT</b>\n"
            f"ğŸ“ˆ SÃ©quence: <b>{gap.polarity.upper()} #{gap.sequence_number}</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        )
        await self.send_message(text)

    async def notify_reversal(self, gap: ExternalGap, prev_polarity: str, prev_sequence: int, prev_level: float,
                             trade_result: Optional[TradeResult] = None):
        """Notification for trend reversal with profit tracking"""
        old_emoji = "ğŸ”´" if prev_polarity == "bearish" else "ğŸŸ¢"
        new_emoji = "ğŸŸ¢" if gap.polarity == "bullish" else "ğŸ”´"

        # Build profit section if trade exists
        profit_section = ""
        if trade_result:
            pnl_emoji = "âœ…" if trade_result.gross_pnl > 0 else "âŒ"
            win_rate = (trade_result.closed_sequence / (trade_result.closed_sequence + (trade_result.opened_sequence - trade_result.closed_sequence)) * 100) if trade_result.closed_sequence > 0 else 0
            # Get cumulative stats from state (passed via trade recording)
            profit_section = (
                f"\nğŸ’° <b>P&L Position FermÃ©e:</b>\n"
                f"  {pnl_emoji} {trade_result.closed_side}: "
                f"<b>{trade_result.gross_pnl:+.2f} USD ({trade_result.pnl_percent:+.2f}%)</b>\n"
                f"  ğŸ“Š EntrÃ©e: {trade_result.entry_price:,.2f} â†’ Sortie: {trade_result.exit_price:,.2f}\n"
                f"  ğŸ”¢ QuantitÃ©: {trade_result.quantity:.6f} {gap.symbol.replace('USDT', '')}\n"
                f"\n"
            )

        text = (
            f"ğŸ”„ <b>INVERSION DE TENDANCE - {gap.symbol}</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"â° {gap.detection_bar_time.strftime('%H:%M:%S')} UTC\n"
            f"{old_emoji} <b>{prev_polarity.upper()} #{prev_sequence}</b> â†’ "
            f"{new_emoji} <b>{gap.polarity.upper()} #{gap.sequence_number}</b>\n"
            f"ğŸ’° Nouveau niveau: <b>{gap.gap_level:,.2f} USDT</b>\n"
            f"ğŸ“Š Gap prÃ©cÃ©dent: {prev_level:,.2f} ({prev_polarity} #{prev_sequence})\n"
            f"{profit_section}"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"ğŸ’µ Prix d'entrÃ©e nouvelle position: <b>{gap.detection_candle_close:,.2f} USDT</b>"
        )
        await self.send_message(text)

    async def notify_stats(self, symbol: str, timeframe: str, stats_interval: str, stats: dict):
        """Notification for statistics at configured interval"""
        freq_text = f"{stats['avg_frequency_min']:.1f} min" if stats['avg_frequency_min'] else "N/A"

        current_trend = stats['current_trend']
        current_seq = stats['current_sequence']

        if current_trend == "bullish":
            trend_emoji = "ğŸŸ¢"
            trend_text = f"{trend_emoji} <b>BULLISH #{current_seq}</b>"
        elif current_trend == "bearish":
            trend_emoji = "ğŸ”´"
            trend_text = f"{trend_emoji} <b>BEARISH #{current_seq}</b>"
        else:
            trend_emoji = "âšª"
            trend_text = f"{trend_emoji} <b>N/A</b>"

        # Format uptime (convert minutes to hours/days if needed)
        uptime_min = stats['uptime_minutes']
        if uptime_min < 60:
            uptime_text = f"{uptime_min:.0f}m"
        elif uptime_min < 1440:  # Less than 24 hours
            uptime_text = f"{uptime_min/60:.1f}h"
        else:
            uptime_text = f"{uptime_min/1440:.1f}d"

        # Format cumulative P&L with color emoji
        pnl = stats['cumulative_pnl']
        pnl_emoji = "âœ…" if pnl > 0 else ("âŒ" if pnl < 0 else "â–")

        text = (
            f"ğŸ“Š <b>STATISTIQUES ({stats_interval}) - {symbol}</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"ğŸ• {datetime.now(timezone.utc).strftime('%H:%M')} UTC\n"
            f"â±ï¸ Timeframe: <b>{timeframe}</b>\n"
            f"â³ Uptime: <b>{uptime_text}</b>\n"
            f"\n"
            f"<b>ğŸ“ˆ GAP STATISTICS:</b>\n"
            f"â¬†ï¸ Gaps bullish: <b>{stats['bullish_gaps']}</b>\n"
            f"â¬‡ï¸ Gaps bearish: <b>{stats['bearish_gaps']}</b>\n"
            f"ğŸ”„ Inversions: <b>{stats['reversals']}</b>\n"
            f"â±ï¸ FrÃ©quence moyenne: {freq_text}\n"
            f"ğŸ’¡ Tendance actuelle: {trend_text}\n"
            f"\n"
            f"<b>ğŸ’° TRADING PERFORMANCE:</b>\n"
            f"{pnl_emoji} P&L cumulÃ©: <b>{pnl:+.2f} USD</b>\n"
            f"ğŸ“Š Nombre de trades: <b>{stats['total_trades']}</b>\n"
            f"âœ… Trades gagnants: <b>{stats['winning_trades']}</b>\n"
            f"âŒ Trades perdants: <b>{stats['losing_trades']}</b>\n"
            f"ğŸ¯ Win rate: <b>{stats['win_rate']:.1f}%</b>\n"
            f"ğŸ’µ Volume cumulÃ©: <b>${stats['cumulative_volume_usd']:,.0f}</b>\n"
            f"\n"
            f"<b>ğŸ“‰ AVERAGES:</b>\n"
            f"âœ… Trade moyen gagnant: <b>+{stats['avg_winning_trade']:.2f} USD</b>\n"
            f"âŒ Trade moyen perdant: <b>{stats['avg_losing_trade']:.2f} USD</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        )
        await self.send_message(text)

    async def notify_startup(self, symbol: str, timeframe: str, stats_interval: str):
        """Notification for bot startup"""
        text = (
            f"ğŸš€ <b>BOT V3 DÃ‰MARRÃ‰ - {symbol}</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"â° {datetime.now(timezone.utc).strftime('%H:%M:%S')} UTC\n"
            f"ğŸ“Š Version: <b>V3 (PineScript Algorithm)</b>\n"
            f"â±ï¸ Timeframe: <b>{timeframe}</b>\n"
            f"ğŸ“ˆ Stats interval: <b>{stats_interval}</b>\n"
            f"ğŸ” Statut: <b>Surveillance active</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"âœ… DÃ©tection des gaps externes en cours..."
        )
        await self.send_message(text)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# WEBSOCKET DETECTOR
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class BinanceExtGapDetector:
    """Main detector with WebSocket connection and candle synchronization"""

    def __init__(
        self,
        symbol: str,
        timeframe: str,
        timeframe_minutes: int,
        stats_interval: str,
        stats_interval_minutes: int,
        output_path: Path,
        telegram: Optional[TelegramNotifier] = None
    ):
        self.symbol = symbol.upper()
        self.timeframe = timeframe
        self.timeframe_minutes = timeframe_minutes
        self.stats_interval = stats_interval
        self.state = GapDetectorState(self.symbol, stats_interval_minutes)
        self.csv_recorder = GapCSVRecorder(output_path)

        # Initialize trade CSV recorder (replace _gaps.csv with _trades.csv)
        trades_path = Path(str(output_path).replace('_gaps.csv', '_trades.csv'))
        self.trade_recorder = TradeCSVRecorder(trades_path)

        self.telegram = telegram

        # WebSocket config
        self.ws_url = f"wss://fstream.binance.com/ws/{self.symbol.lower()}@kline_{timeframe}"
        self.reconnect_delay = 1
        self.max_reconnect_delay = 60

        # Candle synchronization
        self.first_aligned_candle_received = False
        self.last_candle_time: Optional[datetime] = None

    async def _handle_candle(self, candle: Candle):
        """Process closed candle with synchronization validation"""

        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Candle synchronization check
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        # Check if candle is aligned to timeframe boundary
        if not is_candle_aligned(candle.open_time, self.timeframe_minutes):
            logging.error(f"âŒ MISALIGNED CANDLE: {candle.open_time} (expected alignment to {self.timeframe_minutes}m)")

        # Detect missing candles
        if self.last_candle_time is not None:
            expected_next = self.last_candle_time + timedelta(minutes=self.timeframe_minutes)
            if candle.open_time > expected_next:
                missing_count = int((candle.open_time - expected_next).total_seconds() / (self.timeframe_minutes * 60))
                logging.warning(f"âš ï¸ GAP IN DATA: {self.last_candle_time} â†’ {candle.open_time} ({missing_count} candles missing)")

        self.last_candle_time = candle.open_time

        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Log candle
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        logging.info(f"Closed candle: {candle.close_time} | O:{candle.open:.2f} H:{candle.high:.2f} L:{candle.low:.2f} C:{candle.close:.2f}")

        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Detect gap
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        gap = self.state.add_candle(candle)

        if gap:
            logging.info(f"ğŸš¨ GAP DETECTED: {gap.polarity.upper()} #{gap.sequence_number} at {gap.gap_level:.2f} | "
                        f"First:{gap.is_first_gap} Reversal:{gap.is_reversal} GroupSize:{gap.group_size_before_cleanup}")

            # Record to CSV
            self.csv_recorder.record_gap(gap)

            # Send Telegram notifications
            if self.telegram:
                if gap.is_first_gap:
                    await self.telegram.notify_first_gap(gap)
                elif gap.is_reversal:
                    # Record trade if exists
                    if gap.trade_result:
                        self.trade_recorder.record_trade(
                            gap.trade_result,
                            self.state.cumulative_pnl,
                            self.state.total_trades,
                            self.state.winning_trades
                        )

                    prev_polarity = "bearish" if gap.polarity == "bullish" else "bullish"
                    prev_sequence = gap.sequence_number - 1 if not gap.is_reversal else self.state.current_sequence_number - 1
                    # Calculate previous sequence (was just before reset)
                    if gap.polarity == "bullish":
                        prev_sequence = self.state.bearish_gaps  # Total bearish gaps before this reversal
                    else:
                        prev_sequence = self.state.bullish_gaps - 1  # Total bullish gaps before this reversal (minus current one)

                    await self.telegram.notify_reversal(
                        gap,
                        prev_polarity,
                        prev_sequence if prev_sequence > 0 else 1,
                        self.state.last_gap_level or 0,
                        gap.trade_result  # Pass trade result for profit display
                    )
                else:
                    await self.telegram.notify_gap(gap)

        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Check if should send stats
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        if self.state.should_send_stats(candle.close_time):
            if self.telegram and self.state.total_gaps > 0:
                stats = self.state.get_stats()
                await self.telegram.notify_stats(
                    self.symbol,
                    self.timeframe,
                    self.stats_interval,
                    stats
                )

    async def listen(self):
        """Main WebSocket listen loop with auto-reconnect and candle synchronization"""
        while True:
            try:
                logging.info(f"Connecting to Binance WebSocket: {self.ws_url}")
                async with websockets.connect(self.ws_url) as ws:
                    logging.info("âœ… WebSocket connected")
                    self.reconnect_delay = 1  # Reset delay on successful connection

                    async for message in ws:
                        try:
                            data = json.loads(message)

                            # Debug: Log all message types
                            event_type = data.get('e', 'unknown')
                            logging.debug(f"WebSocket message received: event={event_type}")

                            # Only process closed candles
                            if event_type == 'kline':
                                k = data['k']
                                is_closed = k['x']
                                logging.debug(f"Kline message: symbol={k['s']}, interval={k['i']}, closed={is_closed}, price={k['c']}")

                                if is_closed:
                                    candle = Candle.from_websocket(self.symbol, data['k'])

                                    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                                    # Wait for first aligned candle
                                    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

                                    if not self.first_aligned_candle_received:
                                        if is_candle_aligned(candle.open_time, self.timeframe_minutes):
                                            logging.info(f"âœ… First aligned candle received: {candle.open_time}")
                                            self.first_aligned_candle_received = True
                                        else:
                                            logging.warning(f"âš ï¸ Skipping misaligned candle: {candle.open_time} "
                                                           f"(waiting for {self.timeframe_minutes}m boundary)")
                                            continue

                                    # Process candle
                                    await self._handle_candle(candle)

                        except json.JSONDecodeError as e:
                            logging.error(f"Failed to parse WebSocket message: {message[:200]}... Error: {e}")
                        except Exception as e:
                            logging.error(f"Error processing message: {e}", exc_info=True)

            except websockets.exceptions.WebSocketException as e:
                logging.error(f"WebSocket error: {e}")
            except Exception as e:
                logging.error(f"Unexpected error: {e}", exc_info=True)

            # Reconnect with exponential backoff
            logging.warning(f"Reconnecting in {self.reconnect_delay}s...")
            await asyncio.sleep(self.reconnect_delay)
            self.reconnect_delay = min(self.reconnect_delay * 2, self.max_reconnect_delay)

            # Reset alignment flag on reconnection
            self.first_aligned_candle_received = False


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LOGGING SETUP
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def setup_logging(log_file: Path, level: str = "INFO"):
    """Configure logging to file and console"""
    log_file.parent.mkdir(parents=True, exist_ok=True)

    logging.basicConfig(
        level=getattr(logging, level.upper()),
        format='%(asctime)s | %(levelname)-8s | %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S',
        handlers=[
            logging.FileHandler(log_file),
            logging.StreamHandler(sys.stdout)
        ]
    )


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def main():
    """Main entry point"""

    # Interactive configuration
    config = prompt_configuration()

    # Setup paths
    script_dir = Path(__file__).parent
    workspace_root = get_workspace_root(Path(__file__))
    symbol_lower = config["symbol"].lower()
    timeframe = config["timeframe"]

    csv_filename = f"extgap_v3_{symbol_lower}_{timeframe}_gaps.csv"
    log_filename = f"extgap_v3_{symbol_lower}_{timeframe}.log"

    output_path = workspace_root / "data" / "detectors" / csv_filename
    log_path = workspace_root / "logs" / "detectors" / log_filename

    # Setup logging (DEBUG level for troubleshooting)
    setup_logging(log_path, level="DEBUG")

    logging.info("=" * 80)
    logging.info("Binance External Gap Detector - Version 3 (PineScript Algorithm)")
    logging.info("=" * 80)
    logging.info(f"Symbol: {config['symbol']}")
    logging.info(f"Timeframe: {config['timeframe']} ({config['timeframe_minutes']} minutes)")
    logging.info(f"Stats interval: {config['stats_interval']} ({config['stats_interval_minutes']} minutes)")
    logging.info(f"Output CSV: {output_path}")
    logging.info(f"Log file: {log_path}")
    logging.info("=" * 80)

    # Setup Telegram
    telegram = TelegramNotifier.from_env()
    if telegram:
        logging.info(f"âœ… Telegram notifications enabled ({len(telegram.chat_ids)} chats)")
        # Send startup notification
        await telegram.notify_startup(config["symbol"], config["timeframe"], config["stats_interval"])
    else:
        logging.warning("âš ï¸  Telegram notifications disabled (credentials not found)")

    # Start detector
    detector = BinanceExtGapDetector(
        symbol=config["symbol"],
        timeframe=config["timeframe"],
        timeframe_minutes=config["timeframe_minutes"],
        stats_interval=config["stats_interval"],
        stats_interval_minutes=config["stats_interval_minutes"],
        output_path=output_path,
        telegram=telegram
    )

    await detector.listen()


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logging.info("\n" + "=" * 80)
        logging.info("Shutdown requested by user (Ctrl+C)")
        logging.info("=" * 80)
        sys.exit(0)
