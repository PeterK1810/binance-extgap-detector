#!/usr/bin/env python3
"""
Binance External Gap Detector - Version 2 (Corrected Reset Logic)
===================================================================

Pure gap detection without trade simulation.
Reset logic (corrected from PineScript analysis):
- After bearish gap â†’ bearish_candidate = high (opposite extreme)
- After bullish gap â†’ bullish_candidate = low (opposite extreme)

Features:
- Real-time Binance Futures WebSocket (2m timeframe)
- External gap detection using candidate extreme tracking
- First-reversal logic (no trade on first gap)
- CSV logging of all gap detections
- Rich Telegram notifications (4 types)
- Hourly statistics

Author: Generated by Claude Code
Date: 2025-11-12
"""

import asyncio
import json
import logging
import os
import sys
from collections import deque
from dataclasses import dataclass, field
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional, Deque
import argparse

import websockets
import aiohttp
from dotenv import load_dotenv

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DEFAULT_SYMBOL = "BTCUSDT"
DEFAULT_TIMEFRAME = "2m"
DEFAULT_OUTPUT_DIR = "data"
DEFAULT_LOG_DIR = "logs"

# Load environment variables from parent directory
parent_env = Path(__file__).parent.parent / ".env"
if parent_env.exists():
    load_dotenv(parent_env)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DATA MODELS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class Candle:
    """Closed kline data from Binance"""
    symbol: str
    open_time: datetime
    close_time: datetime
    open: float
    high: float
    low: float
    close: float
    volume: float

    @classmethod
    def from_websocket(cls, symbol: str, kline_data: dict) -> 'Candle':
        """Parse candle from Binance WebSocket kline event"""
        return cls(
            symbol=symbol,
            open_time=datetime.fromtimestamp(kline_data['t'] / 1000, tz=timezone.utc),
            close_time=datetime.fromtimestamp(kline_data['T'] / 1000, tz=timezone.utc),
            open=float(kline_data['o']),
            high=float(kline_data['h']),
            low=float(kline_data['l']),
            close=float(kline_data['c']),
            volume=float(kline_data['v'])
        )


@dataclass
class ExternalGap:
    """External gap detection event"""
    detected_at: datetime
    symbol: str
    polarity: str  # "bullish" or "bearish"
    gap_level: float
    gap_opening_bar_time: datetime
    detection_bar_time: datetime
    is_first_gap: bool
    is_reversal: bool  # True if polarity changed from previous gap
    sequence_number: int  # Sequence number within current trend
    detection_candle_close: float  # Close price of candle that triggered detection


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# GAP DETECTION STATE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class GapDetectorState:
    """
    External gap detection using candidate extreme tracking.

    Version 2: Corrected reset logic (from PineScript analysis)
    - After bearish gap: bearish_candidate = candle.high (opposite extreme)
    - After bullish gap: bullish_candidate = candle.low (opposite extreme)

    This ensures candidates are reset to the extreme that would prevent
    immediate re-detection of the same gap type.
    """

    def __init__(self, symbol: str):
        self.symbol = symbol
        self.candle_history: Deque[Candle] = deque(maxlen=500)

        # Candidate tracking (extremes since last gap)
        self.bearish_candidate_low: Optional[float] = None  # Highest low
        self.bearish_candidate_idx: Optional[datetime] = None
        self.bullish_candidate_high: Optional[float] = None  # Lowest high
        self.bullish_candidate_idx: Optional[datetime] = None

        # Gap tracking
        self.last_gap_time: Optional[datetime] = None
        self.last_gap_level: Optional[float] = None
        self.last_gap_polarity: Optional[str] = None

        # First-gap logic
        self.first_gap_detected: bool = False

        # Sequence tracking
        self.current_sequence_number: int = 0
        self.last_sequence_number: int = 0  # Previous sequence before reversal

        # Statistics
        self.total_gaps: int = 0
        self.bullish_gaps: int = 0
        self.bearish_gaps: int = 0
        self.reversals: int = 0
        self.last_stats_hour: Optional[datetime] = None

    def add_candle(self, candle: Candle) -> Optional[ExternalGap]:
        """
        Process new closed candle and detect external gaps.

        Returns:
            ExternalGap if gap detected, None otherwise
        """
        self.candle_history.append(candle)

        # Initialize candidates if first candle
        if self.bearish_candidate_low is None:
            self.bearish_candidate_low = candle.low
            self.bearish_candidate_idx = candle.open_time
            self.bullish_candidate_high = candle.high
            self.bullish_candidate_idx = candle.open_time
            return None

        # Update candidates BEFORE checking for gap
        if candle.low > self.bearish_candidate_low:
            self.bearish_candidate_low = candle.low
            self.bearish_candidate_idx = candle.open_time

        if candle.high < self.bullish_candidate_high:
            self.bullish_candidate_high = candle.high
            self.bullish_candidate_idx = candle.open_time

        # Check for external gap
        bullish_gap = candle.low > self.bullish_candidate_high
        bearish_gap = candle.high < self.bearish_candidate_low

        if not (bullish_gap or bearish_gap):
            return None

        # Gap detected!
        is_bearish = bearish_gap
        polarity = "bearish" if is_bearish else "bullish"
        gap_level = self.bearish_candidate_low if is_bearish else self.bullish_candidate_high
        gap_opening_bar_time = self.bearish_candidate_idx if is_bearish else self.bullish_candidate_idx

        # Check if first gap or reversal
        is_first = not self.first_gap_detected
        is_reversal = False

        if is_first:
            self.first_gap_detected = True
            self.current_sequence_number = 1  # Initialize sequence
        elif self.last_gap_polarity is not None and self.last_gap_polarity != polarity:
            is_reversal = True
            self.reversals += 1
            self.last_sequence_number = self.current_sequence_number  # Save previous sequence
            self.current_sequence_number = 1  # Reset sequence on reversal
        else:
            # Same polarity - increment sequence
            self.current_sequence_number += 1

        # Update gap tracking
        self.last_gap_time = candle.close_time
        self.last_gap_level = gap_level
        self.last_gap_polarity = polarity

        # Update statistics
        self.total_gaps += 1
        if is_bearish:
            self.bearish_gaps += 1
        else:
            self.bullish_gaps += 1

        # RESET CANDIDATES (V2 Corrected Logic)
        # After bearish gap: reset both candidates to HIGH (opposite extreme)
        # After bullish gap: reset both candidates to LOW (opposite extreme)
        if is_bearish:
            # Bearish gap means price dropped below bearish_candidate_low
            # Reset bearish candidate to HIGH to require price to rise before next bearish gap
            self.bearish_candidate_low = candle.high
            self.bearish_candidate_idx = candle.open_time
            self.bullish_candidate_high = candle.high
            self.bullish_candidate_idx = candle.open_time
        else:
            # Bullish gap means price rose above bullish_candidate_high
            # Reset bullish candidate to LOW to require price to drop before next bullish gap
            self.bearish_candidate_low = candle.low
            self.bearish_candidate_idx = candle.open_time
            self.bullish_candidate_high = candle.low
            self.bullish_candidate_idx = candle.open_time

        return ExternalGap(
            detected_at=datetime.now(timezone.utc),
            symbol=self.symbol,
            polarity=polarity,
            gap_level=gap_level,
            gap_opening_bar_time=gap_opening_bar_time,
            detection_bar_time=candle.close_time,
            is_first_gap=is_first,
            is_reversal=is_reversal,
            sequence_number=self.current_sequence_number,
            detection_candle_close=candle.close
        )

    def get_stats(self) -> dict:
        """Get current statistics"""
        avg_frequency_min = None
        if self.total_gaps > 1 and self.candle_history:
            elapsed = (self.candle_history[-1].close_time - self.candle_history[0].open_time).total_seconds() / 60
            avg_frequency_min = elapsed / self.total_gaps if self.total_gaps > 0 else None

        return {
            "total_gaps": self.total_gaps,
            "bullish_gaps": self.bullish_gaps,
            "bearish_gaps": self.bearish_gaps,
            "reversals": self.reversals,
            "current_trend": self.last_gap_polarity or "N/A",
            "current_sequence": self.current_sequence_number,
            "avg_frequency_min": avg_frequency_min
        }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CSV RECORDER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class GapCSVRecorder:
    """Records gap detections to CSV file"""

    def __init__(self, output_path: Path):
        self.output_path = output_path
        self.output_path.parent.mkdir(parents=True, exist_ok=True)

        # Create file with headers if doesn't exist
        if not self.output_path.exists():
            with open(self.output_path, 'w') as f:
                f.write("detected_at_utc,symbol,polarity,sequence_number,gap_level,gap_opening_bar_time,detection_bar_time,is_first_gap,is_reversal\n")

    def record_gap(self, gap: ExternalGap):
        """Append gap detection to CSV"""
        with open(self.output_path, 'a') as f:
            f.write(f"{gap.detected_at.isoformat()},"
                   f"{gap.symbol},"
                   f"{gap.polarity},"
                   f"{gap.sequence_number},"
                   f"{gap.gap_level:.2f},"
                   f"{gap.gap_opening_bar_time.isoformat()},"
                   f"{gap.detection_bar_time.isoformat()},"
                   f"{gap.is_first_gap},"
                   f"{gap.is_reversal}\n")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TELEGRAM NOTIFIER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class TelegramNotifier:
    """Send rich Telegram notifications"""

    def __init__(self, bot_token: str, chat_ids: list[str]):
        self.bot_token = bot_token
        self.chat_ids = chat_ids
        self.base_url = f"https://api.telegram.org/bot{bot_token}"

    @classmethod
    def from_env(cls) -> Optional['TelegramNotifier']:
        """Load from environment variables"""
        bot_token = os.getenv("TELEGRAM_BOT_TOKEN_EXTGAP_DETECTOR")
        chat_ids_str = os.getenv("TELEGRAM_CHAT_IDS_EXTGAP_DETECTOR")

        if not bot_token or not chat_ids_str:
            logging.warning("Telegram credentials not found in environment")
            return None

        chat_ids = [cid.strip() for cid in chat_ids_str.split(',')]
        return cls(bot_token, chat_ids)

    async def send_message(self, text: str):
        """Send message to all configured chat IDs"""
        async with aiohttp.ClientSession() as session:
            for chat_id in self.chat_ids:
                try:
                    await session.post(
                        f"{self.base_url}/sendMessage",
                        json={"chat_id": chat_id, "text": text, "parse_mode": "HTML"}
                    )
                except Exception as e:
                    logging.error(f"Failed to send Telegram message to {chat_id}: {e}")

    async def notify_first_gap(self, gap: ExternalGap):
        """Notification for first gap detected"""
        emoji = "â¬†ï¸" if gap.polarity == "bullish" else "â¬‡ï¸"
        text = (
            f"ğŸš€ <b>PREMIER GAP DÃ‰TECTÃ‰ - {gap.symbol}</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"â° {gap.detection_bar_time.strftime('%H:%M:%S')} UTC\n"
            f"ğŸ“Š PolaritÃ©: <b>{gap.polarity.upper()} #{gap.sequence_number}</b> {emoji}\n"
            f"ğŸ’° Niveau: <b>{gap.gap_level:,.2f} USDT</b>\n"
            f"ğŸ•’ Barre ouverture: {gap.gap_opening_bar_time.strftime('%H:%M:%S')}\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"âš ï¸ Pas de trade - attente inversion"
        )
        await self.send_message(text)

    async def notify_initial_trend(self, gap: ExternalGap):
        """Notification for initial external gap trend detected"""
        emoji = "ğŸŸ¢" if gap.polarity == "bullish" else "ğŸ”´"
        trend_arrow = "â¬†ï¸" if gap.polarity == "bullish" else "â¬‡ï¸"
        text = (
            f"ğŸ“ˆ <b>TENDANCE INITIALE DÃ‰TECTÃ‰E - {gap.symbol}</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"â° {datetime.now(timezone.utc).strftime('%H:%M:%S')} UTC\n"
            f"ğŸ’¡ Tendance: {emoji} <b>{gap.polarity.upper()}</b> {trend_arrow}\n"
            f"ğŸ’° Niveau du gap: <b>{gap.gap_level:,.2f} USDT</b>\n"
            f"ğŸ•’ DÃ©tectÃ© Ã : {gap.detection_bar_time.strftime('%H:%M:%S')}\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"âœ… Le bot surveille maintenant les inversions de tendance"
        )
        await self.send_message(text)

    async def notify_gap(self, gap: ExternalGap, gap_count: int):
        """Notification for normal gap (same polarity)"""
        emoji = "â¬†ï¸" if gap.polarity == "bullish" else "â¬‡ï¸"
        text = (
            f"ğŸ“Š <b>GAP {gap.polarity.upper()} #{gap.sequence_number} DÃ‰TECTÃ‰ - {gap.symbol}</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"â° {gap.detection_bar_time.strftime('%H:%M:%S')} UTC\n"
            f"ğŸ’° Niveau: <b>{gap.gap_level:,.2f} USDT</b>\n"
            f"ğŸ“ˆ SÃ©quence: <b>{gap.polarity.upper()} #{gap.sequence_number}</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        )
        await self.send_message(text)

    async def notify_reversal(self, gap: ExternalGap, prev_polarity: str, prev_sequence: int, prev_level: float):
        """Notification for trend reversal"""
        old_emoji = "ğŸ”´" if prev_polarity == "bearish" else "ğŸŸ¢"
        new_emoji = "ğŸŸ¢" if gap.polarity == "bullish" else "ğŸ”´"
        text = (
            f"ğŸ”„ <b>INVERSION DE TENDANCE - {gap.symbol}</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"â° {gap.detection_bar_time.strftime('%H:%M:%S')} UTC\n"
            f"{old_emoji} <b>{prev_polarity.upper()} #{prev_sequence}</b> â†’ {new_emoji} <b>{gap.polarity.upper()} #{gap.sequence_number}</b>\n"
            f"ğŸ’° Nouveau niveau: <b>{gap.gap_level:,.2f} USDT</b>\n"
            f"ğŸ“Š Gap prÃ©cÃ©dent: {prev_level:,.2f} ({prev_polarity} #{prev_sequence})\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"ğŸ’µ Prix d'entrÃ©e nouvelle position: <b>{gap.detection_candle_close:,.2f} USDT</b>"
        )
        await self.send_message(text)

    async def notify_hourly_stats(self, symbol: str, stats: dict):
        """Notification for hourly statistics"""
        freq_text = f"{stats['avg_frequency_min']:.1f} min" if stats['avg_frequency_min'] else "N/A"

        current_trend = stats['current_trend']
        current_seq = stats['current_sequence']

        if current_trend == "bullish":
            trend_emoji = "ğŸŸ¢"
            trend_text = f"{trend_emoji} <b>BULLISH #{current_seq}</b>"
        elif current_trend == "bearish":
            trend_emoji = "ğŸ”´"
            trend_text = f"{trend_emoji} <b>BEARISH #{current_seq}</b>"
        else:
            trend_emoji = "âšª"
            trend_text = f"{trend_emoji} <b>N/A</b>"

        text = (
            f"ğŸ“Š <b>STATISTIQUES HORAIRES - {symbol}</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"ğŸ• {datetime.now(timezone.utc).strftime('%H:%M')} UTC\n"
            f"â¬†ï¸ Gaps bullish: <b>{stats['bullish_gaps']}</b>\n"
            f"â¬‡ï¸ Gaps bearish: <b>{stats['bearish_gaps']}</b>\n"
            f"ğŸ”„ Inversions: <b>{stats['reversals']}</b>\n"
            f"â±ï¸ FrÃ©quence moyenne: {freq_text}\n"
            f"ğŸ’¡ Tendance actuelle: {trend_text}\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        )
        await self.send_message(text)

    async def notify_startup(self, symbol: str, timeframe: str, version: str = "v2"):
        """Notification for bot startup"""
        import os
        instance_id = os.getenv("INSTANCE_ID", "UNKNOWN")
        version_name = "Simple Reset Logic" if version == "v1" else "Corrected Reset Logic"
        text = (
            f"ğŸš€ <b>BOT DETECTOR {version.upper()} DÃ‰MARRÃ‰ - {symbol}</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"â° {datetime.now(timezone.utc).strftime('%H:%M:%S')} UTC\n"
            f"ğŸ“Š Version: <b>{version.upper()}</b> ({version_name})\n"
            f"ğŸ–¥ï¸ Instance: <b>{instance_id}</b>\n"
            f"â±ï¸ Timeframe: <b>{timeframe}</b>\n"
            f"ğŸ” Statut: <b>Surveillance active</b>\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"âœ… DÃ©tection des gaps externes en cours..."
        )
        await self.send_message(text)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# WEBSOCKET LOOP
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class BinanceExtGapDetector:
    """Main detector with WebSocket connection"""

    def __init__(
        self,
        symbol: str,
        timeframe: str,
        output_path: Path,
        telegram: Optional[TelegramNotifier] = None
    ):
        self.symbol = symbol.upper()
        self.timeframe = timeframe
        self.state = GapDetectorState(self.symbol)
        self.csv_recorder = GapCSVRecorder(output_path)
        self.telegram = telegram

        # WebSocket config
        self.ws_url = f"wss://fstream.binance.com/ws/{self.symbol.lower()}@kline_{timeframe}"
        self.reconnect_delay = 1
        self.max_reconnect_delay = 60

    async def _handle_candle(self, candle: Candle):
        """Process closed candle and handle gap detection"""
        logging.info(f"Closed candle: {candle.close_time} | O:{candle.open:.2f} H:{candle.high:.2f} L:{candle.low:.2f} C:{candle.close:.2f}")

        # Detect gap
        gap = self.state.add_candle(candle)

        if gap:
            logging.info(f"ğŸš¨ GAP DETECTED: {gap.polarity.upper()} at {gap.gap_level:.2f} | First:{gap.is_first_gap} Reversal:{gap.is_reversal}")

            # Record to CSV
            self.csv_recorder.record_gap(gap)

            # Send Telegram notifications
            if self.telegram:
                if gap.is_first_gap:
                    await self.telegram.notify_first_gap(gap)
                    # Also send initial trend notification
                    await self.telegram.notify_initial_trend(gap)
                elif gap.is_reversal:
                    prev_polarity = "bearish" if gap.polarity == "bullish" else "bullish"
                    await self.telegram.notify_reversal(gap, prev_polarity, self.state.last_sequence_number, self.state.last_gap_level or 0)
                else:
                    gap_count = self.state.bullish_gaps if gap.polarity == "bullish" else self.state.bearish_gaps
                    await self.telegram.notify_gap(gap, gap_count)

        # Check if should send hourly stats
        current_hour = candle.close_time.replace(minute=0, second=0, microsecond=0)
        if self.state.last_stats_hour is None:
            self.state.last_stats_hour = current_hour
        elif current_hour > self.state.last_stats_hour:
            self.state.last_stats_hour = current_hour
            if self.telegram and self.state.total_gaps > 0:
                stats = self.state.get_stats()
                await self.telegram.notify_hourly_stats(self.symbol, stats)

    async def listen(self):
        """Main WebSocket listen loop with auto-reconnect"""
        while True:
            try:
                logging.info(f"Connecting to Binance WebSocket: {self.ws_url}")
                async with websockets.connect(self.ws_url) as ws:
                    logging.info("âœ… WebSocket connected")
                    self.reconnect_delay = 1  # Reset delay on successful connection

                    async for message in ws:
                        try:
                            data = json.loads(message)

                            # Only process closed candles
                            if data.get('e') == 'kline' and data['k']['x']:
                                candle = Candle.from_websocket(self.symbol, data['k'])
                                await self._handle_candle(candle)

                        except json.JSONDecodeError:
                            logging.error(f"Failed to parse WebSocket message: {message}")
                        except Exception as e:
                            logging.error(f"Error processing message: {e}", exc_info=True)

            except websockets.exceptions.WebSocketException as e:
                logging.error(f"WebSocket error: {e}")
            except Exception as e:
                logging.error(f"Unexpected error: {e}", exc_info=True)

            # Reconnect with exponential backoff
            logging.warning(f"Reconnecting in {self.reconnect_delay}s...")
            await asyncio.sleep(self.reconnect_delay)
            self.reconnect_delay = min(self.reconnect_delay * 2, self.max_reconnect_delay)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CLI SETUP
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def setup_logging(log_file: Path, level: str = "INFO"):
    """Configure logging to file and console"""
    log_file.parent.mkdir(parents=True, exist_ok=True)

    logging.basicConfig(
        level=getattr(logging, level.upper()),
        format='%(asctime)s | %(levelname)-8s | %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S',
        handlers=[
            logging.FileHandler(log_file),
            logging.StreamHandler(sys.stdout)
        ]
    )


def parse_args():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(
        description="Binance External Gap Detector - Version 2 (Corrected Reset Logic)"
    )
    parser.add_argument(
        "--symbol",
        default=DEFAULT_SYMBOL,
        help=f"Trading symbol (default: {DEFAULT_SYMBOL})"
    )
    parser.add_argument(
        "--timeframe",
        default=DEFAULT_TIMEFRAME,
        help=f"Kline interval (default: {DEFAULT_TIMEFRAME})"
    )
    parser.add_argument(
        "--output",
        default=None,
        help="CSV output path (default: data/extgap_detector_v2_gaps.csv)"
    )
    parser.add_argument(
        "--log-level",
        default="INFO",
        choices=["DEBUG", "INFO", "WARNING", "ERROR"],
        help="Logging level (default: INFO)"
    )

    return parser.parse_args()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def get_workspace_root(script_path: Path) -> Path:
    """
    Find workspace root directory robustly.
    
    Looks for marker files (requirements.txt, README.md, .git) by walking up
    the directory tree from the script location. Falls back to script_dir.parent.parent
    if markers not found. Can also use WORKSPACE_ROOT environment variable.
    
    Args:
        script_path: Path to the current script file
        
    Returns:
        Path to workspace root directory
    """
    import os
    # Check environment variable first
    env_root = os.getenv("WORKSPACE_ROOT")
    if env_root:
        root_path = Path(env_root)
        if root_path.exists() and root_path.is_dir():
            return root_path.resolve()
    
    # Walk up from script directory looking for marker files
    current = script_path.parent.resolve()
    markers = ["requirements.txt", "README.md", ".git"]
    max_depth = 10  # Prevent infinite loops
    
    for _ in range(max_depth):
        # Check if any marker file exists in current directory
        if any((current / marker).exists() for marker in markers):
            return current
        # Stop at filesystem root
        parent = current.parent
        if parent == current:
            break
        current = parent
    
    # Fallback: assume script is at bots/detectors/ or bots/indicators/
    # This maintains backward compatibility
    script_dir = script_path.parent
    return script_dir.parent.parent


async def main():
    """Main entry point"""
    args = parse_args()

    # Setup paths
    script_dir = Path(__file__).parent
    workspace_root = get_workspace_root(Path(__file__))
    output_path = Path(args.output) if args.output else workspace_root / "data" / "detectors" / "extgap_detector_v2_gaps.csv"
    log_path = workspace_root / "logs" / "detectors" / "extgap_detector_v2.log"

    # Setup logging
    setup_logging(log_path, args.log_level)

    logging.info("=" * 80)
    logging.info("Binance External Gap Detector - Version 2 (Corrected Reset Logic)")
    logging.info("=" * 80)
    logging.info(f"Symbol: {args.symbol}")
    logging.info(f"Timeframe: {args.timeframe}")
    logging.info(f"Output: {output_path}")
    logging.info(f"Log: {log_path}")
    logging.info("=" * 80)

    # Setup Telegram
    telegram = TelegramNotifier.from_env()
    if telegram:
        logging.info(f"âœ… Telegram notifications enabled ({len(telegram.chat_ids)} chats)")
        # Send startup notification
        await telegram.notify_startup(args.symbol, args.timeframe, version="v2")
    else:
        logging.warning("âš ï¸  Telegram notifications disabled (credentials not found)")

    # Start detector
    detector = BinanceExtGapDetector(
        symbol=args.symbol,
        timeframe=args.timeframe,
        output_path=output_path,
        telegram=telegram
    )

    await detector.listen()


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logging.info("Shutdown requested by user")
        sys.exit(0)
